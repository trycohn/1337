// frontend/src/components/BracketRenderer.js
import React, { useRef, useMemo } from 'react';
import './BracketRenderer.css';
import { formatManager } from '../utils/tournament/bracketFormats';
import { SingleEliminationFormat } from '../utils/tournament/formats/SingleEliminationFormat';
import { DoubleEliminationFormat } from '../utils/tournament/formats/DoubleEliminationFormat';
import useDragAndZoom from '../hooks/useDragAndZoom';

// –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ñ–æ—Ä–º–∞—Ç—ã
formatManager.register(new SingleEliminationFormat());
formatManager.register(new DoubleEliminationFormat());

const BracketRenderer = ({ games, tournament, onEditMatch, canEditMatches, selectedMatch, setSelectedMatch, format, onMatchClick }) => {
    // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º games –≤–º–µ—Å—Ç–æ matches
    const matches = useMemo(() => games || [], [games]);
    const rendererRef = useRef(null);
    
    // üÜï –°–û–í–†–ï–ú–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–Ø –ò –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–Ø
    const {
        isDragging,
        zoomPercentage,
        zoomIn,
        zoomOut,
        resetAll,
        centerView,
        fitToScreen,
        canZoomIn,
        canZoomOut,
        handlers
    } = useDragAndZoom({
        initialPosition: { x: 0, y: 0 },
        initialZoom: 0.6,
        minZoom: 0.3,
        maxZoom: 3,
        zoomStep: 0.05,
        requireCtrl: true,
        excludeSelectors: [
            '.bracket-navigation-panel',
            '.bracket-nav-icon-button',
            '.bracket-match-card',
            '.bracket-edit-match-btn'
        ],
        onDragStart: (data) => {
            console.log('üéØ –ù–∞—á–∞–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è:', data.position);
        },
        onDragMove: (data) => {
            // –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∫–∞–∂–¥–æ–µ 10-–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —Å–ø–∞–º–∞
            if (data.event.timeStamp % 10 < 1) {
                console.log('üìç –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ:', data.position);
            }
        },
        onDragEnd: (data) => {
            console.log('üéØ –ö–æ–Ω–µ—Ü –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è:', data.position);
        },
        onZoomChange: (data) => {
            console.log('üîç –ò–∑–º–µ–Ω–µ–Ω–∏–µ –º–∞—Å—à—Ç–∞–±–∞:', data.zoom);
        }
    });
    
    // –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ä–º–∞—Ç —Ç—É—Ä–Ω–∏—Ä–∞
    const tournamentFormat = useMemo(() => {
        const formatType = tournament?.bracket_type || 'single_elimination';
        return formatManager.getFormat(formatType);
    }, [tournament?.bracket_type]);
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –º–∞—Ç—á–∏ –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏—Å—Ç–µ–º—É –ø–ª–∞–≥–∏–Ω–æ–≤
    const groupedMatches = useMemo(() => {
        if (!matches || matches.length === 0) return {};
        return tournamentFormat.groupMatches(matches);
    }, [matches, tournamentFormat]);
    
    // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø—É—Å—Ç—ã–µ –º–∞—Ç—á–∏
    if (!matches || matches.length === 0) {
        return (
            <div className="bracket-renderer-container">
                <div className="bracket-empty-message">
                    üéØ –¢—É—Ä–Ω–∏—Ä–Ω–∞—è —Å–µ—Ç–∫–∞ –ø–æ–∫–∞ –Ω–µ —Å–æ–∑–¥–∞–Ω–∞
                </div>
            </div>
        );
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ä–∞—É–Ω–¥–∞ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    const getRoundContext = (round, roundData, bracketType) => {
        const groupedRounds = Object.keys(groupedMatches[bracketType] || {}).map(Number);
        const totalRounds = Math.max(...groupedRounds);
        const matchesInRound = Array.isArray(roundData) ? roundData.length : Object.keys(roundData).length;
        const isLastRound = round === totalRounds;
        
        return {
            bracketType,
            totalRounds,
            matchesInRound,
            isLastRound,
            currentRound: round,
            allRounds: groupedRounds
        };
    };

    // –†–µ–Ω–¥–µ—Ä —Ä–∞—É–Ω–¥–∞ –¥–ª—è Single Elimination
    const renderSingleEliminationRound = (round, roundData, roundName) => {
        const matchesArray = Array.isArray(roundData) ? roundData : Object.values(roundData).flat();
        const matchesCount = matchesArray.length;
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–∞—Ç—á–µ–π –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
        let matchesClass = 'few-matches';
        let columnClass = 'has-few-matches';
        
        if (matchesCount === 1) {
            matchesClass = 'single-match';
            columnClass = 'has-single-match';
        } else if (matchesCount >= 4) {
            matchesClass = 'many-matches';
            columnClass = 'has-many-matches';
        }
        
        return (
            <div key={round} className={`bracket-round-column ${columnClass}`}>
                <div className="bracket-round-header">
                    {roundName}
                </div>
                <div className={`bracket-matches-list ${matchesClass}`}>
                    {matchesArray.map(match => (
                        <div
                            key={match.id}
                            className="bracket-match-container"
                        >
                            <MatchCard
                                match={match}
                                tournament={tournament}
                                onEditMatch={onEditMatch}
                                canEditMatches={canEditMatches}
                                onMatchClick={onMatchClick}
                                customLabel={match.bracket_type === 'placement' ? '3rd Place' : null}
                                matchType={match.bracket_type}
                            />
                        </div>
                    ))}
                </div>
            </div>
        );
    };

    // –†–µ–Ω–¥–µ—Ä —Ä–∞—É–Ω–¥–∞ –¥–ª—è Double Elimination —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Å—Ç–∏–ª–µ–π
    const renderDoubleEliminationRound = (round, matches, bracketType, roundName, context) => {
        const matchesCount = matches.length;
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–∞—Ç—á–µ–π –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
        let matchesClass = 'few-matches';
        let columnClass = 'has-few-matches';
        
        if (matchesCount === 1) {
            matchesClass = 'single-match';
            columnClass = 'has-single-match';
        } else if (matchesCount >= 4) {
            matchesClass = 'many-matches';
            columnClass = 'has-many-matches';
        }
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ä–∞—É–Ω–¥–∞ –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π —Å—Ç–∏–ª–∏–∑–∞—Ü–∏–∏
        let roundType = 'regular';
        if (bracketType === 'loser' && context?.isLastRound) {
            roundType = 'losers-small-final';
        } else if (bracketType === 'grand_final') {
            roundType = 'grand-final';
        }
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π CSS –∫–ª–∞—Å—Å –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ —Ä–∞—É–Ω–¥–∞
        let headerClass = 'bracket-round-header';
        switch (bracketType) {
            case 'winner':
                headerClass += ' bracket-winners-bracket-header';
                break;
            case 'loser':
                headerClass += ' bracket-losers-bracket-header';
                break;
            case 'grand_final':
                headerClass += ' bracket-grand-final-bracket-header';
                break;
            default:
                headerClass += ' bracket-default-bracket-header';
        }
        
        return (
            <div key={`${bracketType}-${round}`} className={`bracket-round-column ${columnClass}`}>
                <div 
                    className={headerClass}
                    data-round-type={roundType}
                >
                    {roundName}
                </div>
                <div className={`bracket-matches-list ${matchesClass}`}>
                    {matches.map(match => (
                        <div
                            key={match.id}
                            className="bracket-match-container"
                            data-match-type={match.bracket_type}
                        >
                            <MatchCard
                                match={match}
                                tournament={tournament}
                                onEditMatch={onEditMatch}
                                canEditMatches={canEditMatches}
                                onMatchClick={onMatchClick}
                                matchType={match.bracket_type}
                                customLabel={roundType === 'losers-small-final' ? 'Small Final' : null}
                            />
                        </div>
                    ))}
                </div>
            </div>
        );
    };

    // –†–µ–Ω–¥–µ—Ä –ø–∞–Ω–µ–ª–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    const renderNavigationPanel = () => (
        <div className="bracket-navigation-panel">
            <button 
                className="bracket-nav-icon-button"
                onClick={zoomOut}
                disabled={!canZoomOut}
                title="–£–º–µ–Ω—å—à–∏—Ç—å –º–∞—Å—à—Ç–∞–±"
            >
                <span className="bracket-nav-icon">‚àí</span>
            </button>
            
            <div className="bracket-zoom-display">
                {zoomPercentage}%
            </div>
            
            <button 
                className="bracket-nav-icon-button"
                onClick={zoomIn}
                disabled={!canZoomIn}
                title="–£–≤–µ–ª–∏—á–∏—Ç—å –º–∞—Å—à—Ç–∞–±"
            >
                <span className="bracket-nav-icon">+</span>
            </button>
            
            <button 
                className="bracket-nav-icon-button"
                onClick={resetAll}
                title="–°–±—Ä–æ—Å–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é –∏ –º–∞—Å—à—Ç–∞–±"
            >
                <span className="bracket-nav-icon">‚åÇ</span>
            </button>
            
            <button 
                className="bracket-nav-icon-button"
                onClick={centerView}
                title="–¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–µ—Ç–∫—É"
            >
                <span className="bracket-nav-icon">‚äô</span>
            </button>
            
            <button 
                className="bracket-nav-icon-button"
                onClick={fitToScreen}
                title="–£–º–µ—Å—Ç–∏—Ç—å —Å–µ—Ç–∫—É –Ω–∞ —ç–∫—Ä–∞–Ω"
            >
                <span className="bracket-nav-icon">‚åë</span>
            </button>
        </div>
    );

    // –û—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–Ω–¥–µ—Ä —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
    if (tournament?.bracket_type === 'double_elimination') {
        // –†–µ–Ω–¥–µ—Ä Double Elimination
        return (
            <div 
                className={`bracket-renderer-container bracket-double-elimination ${isDragging ? 'dragging' : ''}`}
            >
                {renderNavigationPanel()}
                
                <div 
                    className="bracket-renderer"
                    ref={rendererRef}
                    {...handlers}
                >
                    {/* Winners Bracket */}
                    {groupedMatches.winners && Object.keys(groupedMatches.winners).length > 0 && (
                        <div className="bracket-winners-section">
                            <div className="bracket-section-title">üèÜ Winners Bracket</div>
                            <div className="bracket-rounds-container">
                                {Object.entries(groupedMatches.winners)
                                    .sort(([a], [b]) => parseInt(a) - parseInt(b))
                                    .map(([round, matches]) => {
                                        const context = getRoundContext(parseInt(round), matches, 'winner');
                                        const roundName = tournamentFormat.getRoundName(parseInt(round), context);
                                        return renderDoubleEliminationRound(round, matches, 'winner', roundName, context);
                                    })}
                            </div>
                        </div>
                    )}
                    
                    {/* Losers Bracket */}
                    {groupedMatches.losers && Object.keys(groupedMatches.losers).length > 0 && (
                        <div className="bracket-losers-section">
                            <div className="bracket-section-title">üíÄ Losers Bracket</div>
                            <div className="bracket-rounds-container">
                                {Object.entries(groupedMatches.losers)
                                    .sort(([a], [b]) => parseInt(a) - parseInt(b))
                                    .map(([round, matches]) => {
                                        const context = getRoundContext(parseInt(round), matches, 'loser');
                                        const roundName = tournamentFormat.getRoundName(parseInt(round), context);
                                        return renderDoubleEliminationRound(round, matches, 'loser', roundName, context);
                                    })}
                            </div>
                        </div>
                    )}
                    
                    {/* Grand Final */}
                    {groupedMatches.grand_final && Object.keys(groupedMatches.grand_final).length > 0 && (
                        <div className="bracket-grand-final-section">
                            <div className="bracket-section-title">üèÖ Grand Final</div>
                            <div className="bracket-rounds-container">
                                {Object.entries(groupedMatches.grand_final)
                                    .sort(([a], [b]) => parseInt(a) - parseInt(b))
                                    .map(([round, matches]) => {
                                        const context = getRoundContext(parseInt(round), matches, 'grand_final');
                                        const roundName = tournamentFormat.getRoundName(parseInt(round), context);
                                        return renderDoubleEliminationRound(round, matches, 'grand_final', roundName, context);
                                    })}
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    }
    
    // –†–µ–Ω–¥–µ—Ä Single Elimination
    return (
        <div 
            className={`bracket-renderer-container bracket-single-elimination ${isDragging ? 'dragging' : ''}`}
        >
            {renderNavigationPanel()}
            
            <div 
                className="bracket-renderer"
                ref={rendererRef}
                {...handlers}
            >
                <div className="bracket-rounds-container">
                    {Object.entries(groupedMatches)
                        .sort(([a], [b]) => parseInt(a) - parseInt(b))
                        .map(([round, roundData]) => {
                            const context = getRoundContext(parseInt(round), roundData, 'regular');
                            const roundName = tournamentFormat.getRoundName(parseInt(round), context);
                            return renderSingleEliminationRound(round, roundData, roundName);
                        })}
                </div>
            </div>
        </div>
    );
};

// MatchCard –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π bracket_type –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –º–µ—Ç–æ–∫
const MatchCard = ({ match, tournament, onEditMatch, canEditMatches, onMatchClick, customLabel, matchType = 'regular' }) => {
    const getBracketTypeStyle = () => {
        // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ
        if (match.bracket_type === 'placement' || match.is_third_place_match || matchType === 'third-place') {
            return 'bracket-match-card-third-place';
        }
        
        // üÜï –§–ò–ù–ê–õ–¨–ù–´–ô –ú–ê–¢–ß (–º–∞—Ç—á –∑–∞ 1-–µ –º–µ—Å—Ç–æ)
        if (match.bracket_type === 'final' || matchType === 'final') {
            return 'bracket-match-card-final';
        }
        
        switch (match.bracket_type) {
            case 'winner':
                return 'bracket-match-card-winner';
            case 'loser':
                return 'bracket-match-card-loser';
            case 'grand_final':
            case 'grand_final_reset':
                return 'bracket-match-card-grand-final';
            default:
                return 'bracket-match-card-single';
        }
    };

    const getMatchTitle = () => {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Å—Ç–æ–º–Ω—É—é –º–µ—Ç–∫—É –µ—Å–ª–∏ –µ—Å—Ç—å
        if (customLabel) {
            return customLabel;
        }
        
        // üÜï –§–ò–ù–ê–õ–¨–ù–´–ô –ú–ê–¢–ß (–º–∞—Ç—á –∑–∞ 1-–µ –º–µ—Å—Ç–æ)
        if (match.bracket_type === 'final' || matchType === 'final') {
            return '–ú–∞—Ç—á –∑–∞ 1-–µ –º–µ—Å—Ç–æ';
        }
        
        // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ
        if (match.bracket_type === 'placement' || match.is_third_place_match) {
            return '–ú–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ';
        }
        
        // –î–ª—è grand final –º–∞—Ç—á–µ–π (Double Elimination)
        if (match.bracket_type === 'grand_final') {
            return '–ú–∞—Ç—á –∑–∞ 1-–µ –º–µ—Å—Ç–æ'; // üÜï –ò–∑–º–µ–Ω–µ–Ω–æ —Å "Grand Final"
        }
        
        if (match.bracket_type === 'grand_final_reset') {
            return 'Grand Final Reset'; // –û—Å—Ç–∞–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–º –¥–ª—è reset –º–∞—Ç—á–∞
        }
        
        // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –º–∞—Ç—á–∏
        return `–ú–∞—Ç—á ${match.match_number || match.id}`;
    };

    // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    const getParticipantData = (participantIndex) => {
        const participants = match.participants || [];
        const participant = participants[participantIndex];
        
        if (!participant) {
            return {
                name: 'TBD',
                score: null,
                isWinner: false,
                status: 'NO_SHOW'
            };
        }
        
        // üîß –£–õ–£–ß–®–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —É—á–∞—Å—Ç–Ω–∏–∫ TBD
        const isTBD = !participant.id || participant.id === 'tbd' || participant.name === 'TBD';
        
        return {
            name: participant.name || 'TBD',
            score: participant.score !== null && participant.score !== undefined ? participant.score : participant.resultText,
            // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: TBD –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–º
            isWinner: !isTBD && participant.isWinner,
            status: participant.status || 'PLAYED'
        };
    };

    const participant1 = getParticipantData(0);
    const participant2 = getParticipantData(1);

    // üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –§—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –º–∞—Ç—á–∞
    const getMatchStatus = () => {
        if (match.state === 'DONE' || match.state === 'SCORE_DONE') {
            return 'completed';
        }
        if (participant1.name !== 'TBD' && participant2.name !== 'TBD') {
            return 'ready';
        }
        return 'pending';
    };

    const matchStatus = getMatchStatus();
    
    // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –º–∞—Ç—á
    const handleMatchClick = (e) => {
        e.stopPropagation();
        if (onMatchClick) {
            onMatchClick(match);
        }
    };

    return (
        <div 
            className={`bracket-match-card ${getBracketTypeStyle()}`}
            onClick={handleMatchClick}
            style={{ cursor: onMatchClick ? 'pointer' : 'default' }}
        >
            <div className="bracket-match-info">
                <span className="bracket-match-title">{getMatchTitle()}</span>
                <div className="bracket-match-indicators">
                    {(match.bracket_type === 'placement' || match.is_third_place_match) && (
                        <span className="bracket-type-indicator">ü•â</span>
                    )}
                    {(match.bracket_type === 'final' || matchType === 'final') && (
                        <span className="bracket-type-indicator">üèÜ</span>
                    )}
                    {(match.bracket_type === 'grand_final' || match.bracket_type === 'grand_final_reset') && (
                        <span className="bracket-type-indicator">üèÜ</span>
                    )}
                    <span className="bracket-match-number">#{match.match_number || match.id}</span>
                </div>
            </div>
            
            <div className="bracket-match-participants">
                <div className={`bracket-participant ${participant1.name === 'TBD' ? 'tbd' : ''} ${participant1.isWinner ? 'winner' : ''}`}>
                    <span className="bracket-participant-name">{participant1.name}</span>
                    <span className="bracket-participant-score">{participant1.score || '-'}</span>
                </div>
                
                <div className="bracket-vs-separator">vs</div>
                
                <div className={`bracket-participant ${participant2.name === 'TBD' ? 'tbd' : ''} ${participant2.isWinner ? 'winner' : ''}`}>
                    <span className="bracket-participant-name">{participant2.name}</span>
                    <span className="bracket-participant-score">{participant2.score || '-'}</span>
                </div>
            </div>
            
            <div className="bracket-match-status">
                <span className={`bracket-status-badge bracket-status-${matchStatus}`}>
                    {matchStatus === 'completed' ? '–ó–∞–≤–µ—Ä—à–µ–Ω' : 
                     matchStatus === 'ready' ? '–ì–æ—Ç–æ–≤' : '–û–∂–∏–¥–∞–Ω–∏–µ'}
                </span>
            </div>
            
            {canEditMatches && matchStatus === 'ready' && (
                <div className="bracket-edit-match-indicator">
                    <button 
                        className="bracket-edit-match-btn"
                        onClick={(e) => {
                            e.stopPropagation();
                            onEditMatch && onEditMatch(match);
                        }}
                    >
                        ‚úèÔ∏è
                    </button>
                </div>
            )}
        </div>
    );
};

export default BracketRenderer;